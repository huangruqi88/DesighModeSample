## 1.简单工厂模式(SimpleFactory)

		简单工厂：提供一个创建对象的工厂（Factory）实例功能，而不需要具体实现，被创建的类型可以是接口、抽象类、也可以是具体的
				 类。

		简单工厂参与者：
		* Product:抽象产品类，将具体的代码进行抽象和提取后封装在一个抽象产品中。
		* ConcreteProduct:具体产品类，将需要创建的各种不同产品对象的相关代码封装到具体的产品类中。
		* Factory：工厂配，提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数
		  的不同创建不同的具体产品对象。
		* Client：客户端类，只需要调用工厂类的工厂方法并传入想应的参数即可得到一个产品对象。
	
![简单工厂](https://i.imgur.com/66Fu5Yu.png)

	优点： 工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,
		  外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如
		  何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。

	缺点： 由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类
		  只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂
		  类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系
		  统的维护和扩展非常不利；


## 2.策略模式（Strategy）
	策略模式：它定义了算法家族，分别封装起来，让他们之间互相替换,此模式让算法的变化，不会影响到使用它的客户。
		解释：从概念上看所有的这写算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法与
			使用算法尅之间的耦合。
		前言：当不同的行为堆砌在一个类中时，很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，
			 可以在使用这些行为的类中消除条件语句。
		优点：1.Strategy类层次未Context定义了一系列的可重用的算法和行为。继承有助于析取出这些算法中的公共功能。
			 2.简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试
		PS：策略模式使用用来封装算法的，但是在实践中，可以用它来封装几乎任何类型的规则，只要是在分析过程中需要在不同的时间应
			不同的业务规则，就可以使用。
		* 在基本策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。
![策略设计模式](https://i.imgur.com/BSU5jD8.png)

## 3.装饰模式
	装饰设计模式：动态的给对象添加一些额外的职责或者功能，装饰设计模式比生成子类更为灵活。


![装饰模式](https://i.imgur.com/sTdgLI3.png)

		Commponent是定义一个对象接口，可以给这些对象动态地添加职责。ConreteConponent(Person)[人]是定义的一个具体的对象，
	也可以给对象添加一些职责,Decorator装饰抽象类，集成了Component,从而扩展Component的功能，对于Component来说无需知道
	Decorator的存在。所以具体的的装饰对象是ConcreteDocoratorA(GreenHeadgear)[绿帽子]，ConcreteDoceoratorB(YellowTShorts)
	[黄T恤]就是具体的装饰对象，实现给Compomnent添加职责的功能。
	
		PS: 1.其实装饰设计模式就是利用一个方法（函数）来对对象进行包装。被装饰对象的实现和使用这个对象的使用分离开来，每
		个对象只关心自己的功能，不需要关心如何被添加进对象链当中。
		    2.如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是一个ConcreteComponent
		的一个子类。同样，如果只有一个ConcreteDecorator类，那么可以把Decorator类和ConcreteDecorator的责任和成一个类。

## 4.代理模式(Proxy)

	代理模式（Proxy）：未其他对象提供一种代理以控制这个对象的访问。

![代理模式](https://i.imgur.com/TsRnPPe.png)

	理解：由上可知代理模式就是通过Proxy对象去实现另一对象引用。本质上其实很类似商品 —— 中间商 —— 生产厂家这种关系。如果消费者
	     想要买到商品先通过中间商去买生产厂家的商品。
	
	应用：1.远程代理:为一个对象在不同的地址空间提供局部的代表。这样可以隐藏一个对象存在于不同地址空间的事实。
		 2.虚拟代理；根据需要创建开销很大的对象。通过他实例化需要很长时间的真实对象。
		 3.安全代理：用来控制真实对象访问时的权限。
		 4.智能指引:当调用真实的对象时，代理处理另外一些事。
		PS:虽然代理模式有很多种应用本质上都是为其他对象提供一种代理对象用于控制这个对象的访问。
		
		Android中代理模式应用有Binder机制和ActivityManager等

   Android中远程代理的使用[https://www.jianshu.com/p/7e7e08ad0236](https://www.jianshu.com/p/7e7e08ad0236 "Android中远程代理的使用")

   Android中动态代理和代理模式[https://www.2cto.com/kf/201804/739987.html](https://www.2cto.com/kf/201804/739987.html "动态代理和代理模式")
	

#####	代理模式与装饰模式的区别：
		装饰模式：是在不使用继承，不改变原有对象的情况下增加和扩展对象的行为，但是不会禁用这个对象的行为。强调
		功能的扩展。
		代理模式：是控制这个对象的访问，限制对象的行为。也可以扩展功能，但是更偏向于对对象的控制。

## 5. 工厂方法模式(Fractory Method)
		工厂方法模式（Fractory Method）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化
			延迟到其子类
		使用场景:在任何需要生成复杂对象的地方，都可以使用工厂方法模式，复杂对象适合使用工厂模式，用new就可以完成创建的对
			象无需使用工厂模式。

![工厂方法模式](https://i.imgur.com/VICIkns.png)

##### 简单工厂与工厂方法的区别:
		简单工厂：工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类去除了具体产品的依赖。
		工厂方法：客户端需要决定去实现哪一个工厂类来实现功能类，选择判断的问题还存在，也就是说，工厂方法把简单工厂的
			内部逻辑判断移动到了客户端代码来进行。添加功能本来是要修改工厂的，移到客户端修改。
		总结:工厂方法克服了简单工厂违背开闭原则的缺点，又保持了封装对象创建过程中的优点。这两者都是集中封装了对象的创
		   建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与对象的耦合。工厂方法模式是简单工厂模式的进
		   一步抽象和推广。 由于使用了性，工厂方法保持了简单工厂的优点，而且克服了他的缺点。但缺点是由于每增加一个产
		   品，就需要增加一个产品工厂的类，增加了额外的开发量。

## 6.原型模式(Prototype)
		原型模式（Prototype）用原型实例指定创建对象的种类，并通过copy这些原型创建新的对象。
			浅复制：被复制对象的所有变量都含有的对象相同的值，所有的copy对象的引用都指向原对象地址值。
			深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。
		优点：原型模式是在内存中的二进copy，要比直接new一个对象效率高很多，特别是在一个循环体内产生大量对象的时，原型
		   模式可以更好的体现其优点。
		缺点：他的优点也就是他的缺点，直接在内存中copy,构造函数不会执行，在实际开发中应该注意这个潜在的问题。优就是减
		   少了约束，缺点也是减少了约束，需要大家在使用的时候考虑。
		注意：因为浅复制的明显指向同一个对象的缺点，实际开发中使用深复制，避免使用浅复制。
![原型模式](https://i.imgur.com/oHFCb0T.png)

## 7.模板方法模式(TemplateMethod)
		模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法可使得子类在不改变
		   一个算法结构即可重定义该算法的某些特定步骤。

		使用场景：1.多个子类共有的方法，并且逻辑基本相同时。
				 2.重要、复杂的算法，可以把核心算法设计为模板方法，周边相关细节功能由各个子类去实现。
				 3.重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子
				   函数约束行为。
		总结：模板方法简而言之“流程封装”，也就是把某个固定的流程封装到一个final函数中，并且让子类能
			 都定制这个流程中的某些或者所有步骤，也就是父类提取公用的代码，提升代码的复用率，同时也
			 带来了更好的扩展行。
		
			 优点：1.封装不变的部分，扩展可变的部分。
				  2.提取公共的代码,便于维护。
			 缺点： 模板方法会带来代码阅读的难度，会让用户觉得难以理解。

		
![模板方法模式](https://i.imgur.com/xNvTrwy.png)


