## 1.简单工厂模式(SimpleFactory)

		简单工厂：提供一个创建对象的工厂（Factory）实例功能，而不需要具体实现，被创建的类型可以是接口、抽象类、也可以是具体的
				 类。

		简单工厂参与者：
		* Product:抽象产品类，将具体的代码进行抽象和提取后封装在一个抽象产品中。
		* ConcreteProduct:具体产品类，将需要创建的各种不同产品对象的相关代码封装到具体的产品类中。
		* Factory：工厂配，提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入的参数
		  的不同创建不同的具体产品对象。
		* Client：客户端类，只需要调用工厂类的工厂方法并传入想应的参数即可得到一个产品对象。
	
![简单工厂](https://i.imgur.com/66Fu5Yu.png)

	优点： 工厂类是整个模式的关键.包含了必要的逻辑判断,根据外界给定的信息,决定究竟应该创建哪个具体类的对象.通过使用工厂类,
	      外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如
	      何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。

	缺点： 由于工厂类集中了所有实例的创建逻辑，违反了高内聚责任分配原则，将全部创建逻辑集中到了一个工厂类中；它所能创建的类
	      只能是事先考虑到的，如果需要添加新的类，则就需要改变工厂类了。当系统中的具体产品类不断增多时候，可能会出现要求工厂
	      类根据不同条件创建不同实例的需求．这种对条件的判断和对具体产品类型的判断交错在一起，很难避免模块功能的蔓延，对系
	      统的维护和扩展非常不利；


## 2.策略模式（Strategy）
	策略模式：它定义了算法家族，分别封装起来，让他们之间互相替换,此模式让算法的变化，不会影响到使用它的客户。
	解释：从概念上看所有的这写算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法与
	     使用算法尅之间的耦合。
	前言：当不同的行为堆砌在一个类中时，很难避免使用条件语句来选择合适的行为。将这些行为封装在一个个独立的Strategy类中，
	     可以在使用这些行为的类中消除条件语句。
	     优点：1.Strategy类层次未Context定义了一系列的可重用的算法和行为。继承有助于析取出这些算法中的公共功能。
		  2.简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试
		PS：策略模式使用用来封装算法的，但是在实践中，可以用它来封装几乎任何类型的规则，只要是在分析过程中需要在不同的时间应
		    不同的业务规则，就可以使用。
		* 在基本策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象。
![策略设计模式](https://i.imgur.com/BSU5jD8.png)

## 3.装饰模式
	装饰设计模式：动态的给对象添加一些额外的职责或者功能，装饰设计模式比生成子类更为灵活。


![装饰模式](https://i.imgur.com/sTdgLI3.png)

		Commponent是定义一个对象接口，可以给这些对象动态地添加职责。ConreteConponent(Person)[人]是定义的一个具体的对象，
	也可以给对象添加一些职责,Decorator装饰抽象类，集成了Component,从而扩展Component的功能，对于Component来说无需知道
	Decorator的存在。所以具体的的装饰对象是ConcreteDocoratorA(GreenHeadgear)[绿帽子]，ConcreteDoceoratorB(YellowTShorts)
	[黄T恤]就是具体的装饰对象，实现给Compomnent添加职责的功能。
	
		PS: 1.其实装饰设计模式就是利用一个方法（函数）来对对象进行包装。被装饰对象的实现和使用这个对象的使用分离开来，每
		个对象只关心自己的功能，不需要关心如何被添加进对象链当中。
		    2.如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是一个ConcreteComponent
		的一个子类。同样，如果只有一个ConcreteDecorator类，那么可以把Decorator类和ConcreteDecorator的责任和成一个类。

## 4.代理模式(Proxy)

	代理模式（Proxy）：未其他对象提供一种代理以控制这个对象的访问。

![代理模式](https://i.imgur.com/TsRnPPe.png)

	理解：由上可知代理模式就是通过Proxy对象去实现另一对象引用。本质上其实很类似商品 —— 中间商 —— 生产厂家这种关系。如果消费者
	     想要买到商品先通过中间商去买生产厂家的商品。
	
	应用：1.远程代理:为一个对象在不同的地址空间提供局部的代表。这样可以隐藏一个对象存在于不同地址空间的事实。
	      2.虚拟代理；根据需要创建开销很大的对象。通过他实例化需要很长时间的真实对象。
	      3.安全代理：用来控制真实对象访问时的权限。
	      4.智能指引:当调用真实的对象时，代理处理另外一些事。
	      PS:虽然代理模式有很多种应用本质上都是为其他对象提供一种代理对象用于控制这个对象的访问。
		
	      Android中代理模式应用有Binder机制和ActivityManager等

   Android中远程代理的使用[https://www.jianshu.com/p/7e7e08ad0236](https://www.jianshu.com/p/7e7e08ad0236 "Android中远程代理的使用")

   Android中动态代理和代理模式[https://www.2cto.com/kf/201804/739987.html](https://www.2cto.com/kf/201804/739987.html "动态代理和代理模式")
	

#####	代理模式与装饰模式的区别：
	      装饰模式：是在不使用继承，不改变原有对象的情况下增加和扩展对象的行为，但是不会禁用这个对象的行为。强调
	          功能的扩展。
	      代理模式：是控制这个对象的访问，限制对象的行为。也可以扩展功能，但是更偏向于对对象的控制。

## 5. 工厂方法模式(Fractory Method)
		工厂方法模式（Fractory Method）：定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化
		    延迟到其子类
		使用场景:在任何需要生成复杂对象的地方，都可以使用工厂方法模式，复杂对象适合使用工厂模式，用new就可以完成创建的对
		    象无需使用工厂模式。

![工厂方法模式](https://i.imgur.com/VICIkns.png)

##### 简单工厂与工厂方法的区别:
		简单工厂：工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类去除了具体产品的依赖。
		工厂方法：客户端需要决定去实现哪一个工厂类来实现功能类，选择判断的问题还存在，也就是说，工厂方法把简单工厂的
		    内部逻辑判断移动到了客户端代码来进行。添加功能本来是要修改工厂的，移到客户端修改。
		总结:工厂方法克服了简单工厂违背开闭原则的缺点，又保持了封装对象创建过程中的优点。这两者都是集中封装了对象的创
		   建，使得要更换对象时，不需要做大的改动就可实现，降低了客户程序与对象的耦合。工厂方法模式是简单工厂模式的进
		   一步抽象和推广。 由于使用了性，工厂方法保持了简单工厂的优点，而且克服了他的缺点。但缺点是由于每增加一个产
		   品，就需要增加一个产品工厂的类，增加了额外的开发量。

## 6.原型模式(Prototype)
		原型模式（Prototype）用原型实例指定创建对象的种类，并通过copy这些原型创建新的对象。
			浅复制：被复制对象的所有变量都含有的对象相同的值，所有的copy对象的引用都指向原对象地址值。
			深复制：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。
		优点：原型模式是在内存中的二进copy，要比直接new一个对象效率高很多，特别是在一个循环体内产生大量对象的时，原型
		   模式可以更好的体现其优点。
		缺点：他的优点也就是他的缺点，直接在内存中copy,构造函数不会执行，在实际开发中应该注意这个潜在的问题。优就是减
		   少了约束，缺点也是减少了约束，需要大家在使用的时候考虑。
		注意：因为浅复制的明显指向同一个对象的缺点，实际开发中使用深复制，避免使用浅复制。
![原型模式](https://i.imgur.com/oHFCb0T.png)

## 7.模板方法模式(TemplateMethod)
		模板方法模式：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法可使得子类在不改变
		   一个算法结构即可重定义该算法的某些特定步骤。

		使用场景：1.多个子类共有的方法，并且逻辑基本相同时。
			 2.重要、复杂的算法，可以把核心算法设计为模板方法，周边相关细节功能由各个子类去实现。
			 3.重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子
			 数约束行为。
		总结：模板方法简而言之“流程封装”，也就是把某个固定的流程封装到一个final函数中，并且让子类能
		      定制这个流程中的某些或者所有步骤，也就是父类提取公用的代码，提升代码的复用率，同时也
		      带来了更好的扩展行。
		
		      优点：1.封装不变的部分，扩展可变的部分。
			   2.提取公共的代码,便于维护。
		      缺点：模板方法会带来代码阅读的难度，会让用户觉得难以理解。

		
![模板方法模式](https://i.imgur.com/xNvTrwy.png)


## 8.外观模式(Facade)
	外观模式：要求一个子系统的外部与其内部的通信必须统一一个统一的对象进行。门面模式提供一个高层次的接口，使子系统更易于使用。
	使用场景：
		1.Facade提供一个简单统一的接口，对外隐藏子系统的具体实现、隔离变化。
		2.需要构建一个层次的子系统时，只用外观模式定义子系统中每层的入口。如果子系统之间是相互依赖的，可以
		通过Facade接口进行通信，简化他们之间的依赖关系。
	总结：
	      优点：
		   1.可客户程序隐藏子系统细节，因而减少了客户对于子系统的耦合，能够拥抱变化。
		   2.外观类对于子系统接口封装，使得系统更易于使用。
	      缺点：
		   1.外观类接口膨胀。由于子系统的接口都有外观类统一对外暴露，使得外观类的API接口较多，在一定程度上增加
		   了用户的使用成本。
		   2.外观类没有遵循开闭原则，当业务出现变更是，有可能需要直接改变外观类在Android中的使用案例为Context和
		   ContextImple

![外观模式](https://i.imgur.com/2tJrDOl.png)

## 9.建造者模式(Builder)
	建造者模式：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。
	使用场景：
		1.相同的方法，不同的执行顺序，产生不同的事件结果时。
		2.多个部件或者零件，都可以装配到一个对象中，但是产生的运行结果又不相同时。
		3.产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候建造者模式非常合适。
		4.当初始化一个对象特别复杂时，如参数多，且参数都具有默认值时。
	PS：在实际开发中Director觉得经常被省略。而直接使用Builder来进行对象组装，这个Builder通常委链式调用，具体实现以
	setter方法 return this。
	
	总结：
	     优点：
		  1.良好的封装性，使用构建者模式可以使客户端不必知道产品内部的组成细节。
		  2.建造者独立，容易扩展。
	     缺点：会产生多于的Builder对象以及Director对象，消耗内存。

![建造者模式](https://i.imgur.com/PVfECmR.png)


## 10.观察者模式(Observer)
	观察者模式：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖他的对象都会得到通知并被自动更新。
	使用场景：
		1.关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
		2.事件多级出发场景。
		3.跨系统的消息交换场景
	总结：
		 观察者模式主要作用就是对象解耦，将观察者与被观察者完全隔离，只依赖于Observer和Observable抽象。（eg:Android
	  中有ListView就是运用了适配器和观察者模式，广播也是同过观察者实现注册、反注册、更新数据。）
		优点：  
		   1.观察者和被观察者之间是抽象耦合，应对业务变化。
		   2.增强系统灵活性、可扩展性。
		缺点：应用是需要考虑开发效率和运行效率问题，程序中包括一个被观察者、观察者、开发和调试等内容会比较复杂，而且在Java
	       中消息的通知默认是顺序执行，一个观察卡顿，会影响整体的执行效率，在这种情况下，一般考虑使用异步的方式。

![观察者模式](https://i.imgur.com/IvoIxIb.png)

## 11.抽象工厂模式(Abstract Factory)
	抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
	使用场景：一个对象族有相同的约束是可以使用抽象工厂模式。例：Android、iOS下都有短信软件和拨号软件，两者都属于软件范畴，
	   但是他所在的操作系统平台不一样，即使同一家公司出品的软件，其代码的实现逻辑也是不同的，这时候就可以考虑使用抽象工
	   厂方法模式来生产AndroidiOS下的短信软件和拨号软件。
	总结：
	    优点：分离接口与实现，客户端使用抽象工厂来创建需要的对象，而客户端根本就不知道具体的实现是谁，客户端只是面向产品
	       的接口编程而已，使其总具体的产品实现中进行解耦，同时给予接口与实现的分离，使抽象工厂方法模式在切换产品类时，
	       更加灵活、容易
	    缺点：
		    1.类文件的爆炸性增加
		    2.不太容易扩展新的产品类，每增加一个产品类就需要修改抽象工厂，那么所有的具体工厂类均会被修改。
			
![抽象工厂模式](https://i.imgur.com/9Oi56vE.png)
